# src/Synaptipy/templates/analysis_template.py
"""
GOLDEN SAMPLE: This file is the STRICT template for all new analysis modules.
Do not edit this file. It serves as the architectural law for the Agent.
"""
from typing import Dict, Any
import numpy as np
import logging
from Synaptipy.core.analysis.registry import AnalysisRegistry
from Synaptipy.core.results import AnalysisResult  # Ensure this or specific Result class exists

log = logging.getLogger(__name__)  # Rule: Dynamic Logger

# --- PART 1: PURE LOGIC (The Core) ---
# Rule: Must return a Typed Object (AnalysisResult subclass), not a dict.
# Rule: No **kwargs. Explicit arguments only.
def calculate_metric_logic(data: np.ndarray, sampling_rate: float, threshold: float) -> AnalysisResult:
    """
    Pure logic function. No GUI dependencies.
    Returns a typed Result object.
    """
    if data.size == 0:
        return AnalysisResult(value=None, unit='Hz', is_valid=False, error_message="Empty Data")
    
    # ... perform math ...
    result_value = np.mean(data) > threshold
    
    return AnalysisResult(value=result_value, unit='Hz', is_valid=True)

# --- PART 2: THE WRAPPER (The Bridge) ---
# Rule: Decorated with Registry
# Rule: Returns Dict[str, Any] for GUI
@AnalysisRegistry.register(
    name="template_metric",
    label="Template Metric",
    ui_params=[
        {"name": "threshold", "type": "float", "default": 1.0}
    ]
)
def run_metric_wrapper(data: np.ndarray, time: np.ndarray, sampling_rate: float, **kwargs) -> Dict[str, Any]:
    """
    Wrapper function that maps GUI parameters to the core logic.
    Must NOT contain orchestration logic (calling multiple analysis steps).
    """
    # Rule: Extract params with .get() to avoid hardcoding defaults.
    # Pass 'None' if missing to let Core Logic apply scientific defaults.
    threshold = kwargs.get('threshold', None) 
    
    # Rule: Call the logic function
    result = calculate_metric_logic(data, sampling_rate, threshold=threshold)
    
    # Rule: Handle invalid results gracefully
    if not result.is_valid:
        return {'error': result.error_message}

    # Rule: Flatten result for GUI consumption
    return {
        'value': result.value,
        'unit': result.unit,
        # Add other scalar metrics here
    }